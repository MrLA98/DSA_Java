# DSA_Java

### 1. 稀疏数组

### 2. 队列

#### 2.1 数组模拟队列

#### 2.2 数组模拟环形队列

- 修改front和rear变量的含义 - 左闭右开` [front, rear)`
  - front变为队列的开始 -- 初始为0
  - rear变为队列结尾的下一个位置 -- 初始为0
- 队列满 -- `(rear + 1) % maxSize = front`
- 队列空 -- 不变：rear == front
- 队列的有效数据个数 ： `(rear + maxSize - front) % maxSize`

### 3. 链表

- 有头节点、无头结点两种
  - 头节点不放数据
- 节点 = 数据 + 下一个节点地址 = data + next
- 各个节点不一定连续

#### 3.1 单链表

- 注意的点

  - 使用辅助节点来遍历指针
  - 找一个节点时，要看要比较的是它下一个还是它本身
    - 本身的话，从head.next开始，每次比较temp，temp是null则结束遍历
    - 下一个的话，从head开始，每次比较temp.next，temp.next是null则结束遍历

- 需要的功能

  - 初始化

  - 添加节点

  - 删除节点 -- 被删除的节点会被垃圾回收机制回收掉

  - 修改节点

  - 显示链表

  - 按照某种特殊条件来添加节点

- 题目

  - 获取单链表的节点个数
    - 有头节点，不统计头节点
  - 获取单链表的倒数第k个节点
  - 反转单链表
    - 头插法
  - 逆序打印链表
    - 递归
    - 用栈

#### 3.2 双向链表

- 可以自我删除
- 节点
  - next
  - pre
  - data
- 双向指针在添加/删除元素时，经常会遇到
  - cur.next.pre
  - 此时一定要先确认cur的next是不是null

#### 3.3 单项环形链表

- 不带头节点
- 约瑟夫问题
  - 编号为1、2、3、.. 、n的人围坐成一圈
  - 从编号k的人从1开始报数
  - 报到m的那个人出列
  - 下一个人又从1开始报数，数到m的那个人又出列
  - 依次类推，直到所有人出列为止。
  - 产生一个出队编号序列

### 4. 栈

- 先入后出
- 栈顶 -- 输入和输出的那端
- 栈底 -- 不动
- 出栈 -- pop
- 入栈 -- push

#### 4.1 数组模拟栈
- 数组
- 栈顶

#### 4.2 用栈来实现计算器
- 这里用的是中缀表达式
  - 如 23+32/2+2*6
- 两个栈
  - 数栈
  - 符号栈
##### 4.2.1 具体操作
  - 遍历表达式字符串
  - 数字直接入数栈
  - 符号分情况讨论
    1. 符号栈为空直接入符号栈
    2. 当期操作符优先级<=栈中操作符
       - 数栈pop出两个数
       - 符号栈pop出一个操作符
       - 计算结果入数栈
       - 符号入符号栈 
    3. 当前操作符优先级>栈中操作符
       - 符号直接入符号栈 
   - 扫描完成后
     - 数栈弹两个数
     - 符号栈弹一个符号
     - 计算结果放回数栈
     - 以此类推
   - 最后弹出数栈底元素就是计算结果

#### 4.3 三种计算表达式
- 前缀表达式 - 波兰表达式
  - `(3+4)*5-6`  ==  `-*+3456`
- 中缀表达式 - `(3+4)*5-6`
- 后缀表达式 - 逆波兰表达式
  - `(3+4)*5-6` == `34+5*6-`

- 逆波兰计算器

#### 4.4 中缀转后缀表达式
1. 一个栈：运算符栈s1
2. 遍历中缀表达式
3. 遇到数，直接输出
4. 遇到运算符a，比较其与s1顶运算符b的优先级
   - s1 空，或栈顶运算符为'('，直接入栈
   - a>b，直接入栈
   - a<=b，将b输出，重新将a与此时栈顶元素c比较
5. 遇到括号时
   - "("直接放入s1
   - ")"，s1依次往外弹输出，直到遇见")"，删掉这一对括号
6. 重复2~5，直至中缀表达式遍历结束
7. 将s1中剩下的依次弹出输出
8. 所有的输出的结果就是对应的后缀表达式

### 5. 递归
#### 5.1 调用规则
- 当程序执行到一个方法时，就会开辟出一个独立的空间 -- 栈
- 这个空间是受保护、的独立的
- 局部变量被保护在各自的独立空间中，不会相互影响
- 引用类型的变量会共享
- 必须有推出递归条件，且要向推出递归条件逼近，否则是**无限递归**
- 遇到return就返回，谁调用就返回给谁

#### 5.2 迷宫回溯问题
- 下左上右

#### 5.3 N皇后问题
- 因为每行只放一个皇后
  - 所以用一维数组来表示
  - 如：[0,4,7,5,2,6,1,3]

### 6. 排序

- 内部排序
  - 插入排序 -- 直接插入、希尔排序
  - 选择排序 -- 简单选择、堆排序
  - 交换排序 -- 冒泡排序、快排
  - 归并
  - 桶排序 -- 基数排序、计数排序
- 外部排序

---

- 时间复杂度
  - 低次项可忽略、系数可忽略
  - 渐进时间复杂度 -- 时间复杂度
  - O(1)、O(logN)、O(N)、O(NlogN)、O(N^2^)、O(N^3^)、O(N^k^)、O(2^N^)、O(N!)

### 7. 查找
- 线性查找 -- 不要求序列有序
- 二分查找 -- 要求序列有序
  - 递归和非递归
  - `mid = low + (high - low)*0.5`

- 插值查找算法 -- 有序数组
  - `rate = (key - arr[low])/(arr[high] - arr[low])/`
  - `mid = low + (high - low)*rate`
  - 要额外判断mid是否越界

- 斐波那契查找算法
  - 先要将数组扩展至最接近的斐波那契长度，并得到对应的k
    - 即找到使得`arr.length-1 < F(k)`成立的最小的 k
    - 并将数组扩充至`F(k)`，多出来的位置用最后一个数填充
  - `mid = low+F(k-1)-1`
    - 左侧为`F[k-1]`，右侧为`F[k-2]`

### 8. 哈希表
- 本质上是管理链表的数组  
  - 用散列函数定位对象所在链表
  - 将对象放在对应的链表中


### 9. 树
- 节点、根节点、叶子节点
- 二叉树
  - 满二叉树
  - 完全二叉树
  - 前序、中序、后续遍历
---
- 顺序二叉树
  - 数组形式存放
  - [i]的左孩子 -- `2 * i + 1`
  - [i]的右孩子 -- `2 * i + 2`
  - [i]的父节点 -- `(i - 1)/2`

- 堆排序
  - O(NlogN)
  - 大顶堆、小顶堆
  - 基本步骤
    - 数组变成大顶堆
    - 堆顶元素和末尾元素交换
    - 剩下的数再调整为大顶堆
---
- 线索化二叉树
  - 前序、中序、后序
---
- 赫夫曼树（Huffman Tree）
  - n个权值作为n个叶子节点，带权路径最小的就是Huffman树
  - 大权值一定是离根节点更近的
  - 构建Huffman树
    - 排序
    - 根节点权值最小的两个树
    - 组成新树，节点权值为这两个树权值的和
    - 重新按节点权值排序，重复上面步骤

- 赫夫曼编码
  - 统计词频
  - 按词频升序排列字母，构建赫夫曼树
  - 根据树的路径，左是0，右是1，生成每个字母的赫夫曼编码
    - 这样的编码是前缀码
--- 
- 二叉排序树 - BST
  - 左孩子比父亲小，右孩子比父亲大
  - 重点在删除节点的代码，各种情况的处理
    - 没找到目标节点 -- 直接返回
    - 目标节点时头节点，且该树只有头节点 -- root = null，返回
    - 删除叶子节点 -- 找到父亲，判断其是左还是右，置null
    - 删除有一个子树的节点 -- 找到父亲，将目标节点位置只为其子树节点
      - 注意，目标有可能是头节点和其一个子树，此时直接让root为其子树即可
    - 删除有两个子树的节点 -- 右树的最左节点删除，并将其信息复制给目标节点
  - 添加节点的代码 -- 用递归实现